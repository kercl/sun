(* ::Package:: *)

BeginPackage["SUN`"];

	Irrep::usage = 
		"Irredcible representation identified by a Dynkin label.";
	
	IrrepBasis::usage =
		"Set of basis matrices of a particular irreducible representation.";
	
	IrrepDimension::usage = 
		"Compute the dimension of a representation.";
	
	LieAlgebraBasisMatrices::usage =
		"Generate set of basis matrices spanning the particular representation";
	
	IrrepDynkinLabel::usage = 
		"Retrieve the Dynkin label of an irreducible representation.";
	
	SU3BasisMatrices::usage =
		"Construct \[GothicS]\[GothicU](3) Irrep basis";
	
	SU2BasisMatrices::usage =
		"Construct \[GothicS]\[GothicU](2) Irrep basis";
	
	IrrepBuildLoweringRootOperators::usage =
		"TODO";

Begin["Private`"];

	sunLibCore = FindLibrary["sun_core"];
	
	(* Icon used in the summary boxes *)
	iconSize = Dynamic[{Automatic, 3.5 CurrentValue["FontCapHeight"]/AbsoluteCurrentValue[Magnification]}];
	icon = Graphics[({{PointSize[Medium],Point@#},Line@#}&@{
						{1,0},        {1/2,2/Sqrt[3]}, {-(1/2),2/Sqrt[3]},
						{-1,0}, {-(1/2),-(2/Sqrt[3])}, {1/2,-(2/Sqrt[3])},{1,0}})
					~Join~{
						Line[{{-1,0},{1,0}}],
						Line[{{1/2,2/Sqrt[3]},{-(1/2),-(2/Sqrt[3])}}],
						Line[{{1/2,-(2/Sqrt[3])},{-(1/2),2/Sqrt[3]}}]},
					AspectRatio->1,
					ImageSize -> iconSize];

	(* SummaryBox identifying an irreducible representation by its Dynkin Label *)
	Irrep/:MakeBoxes[
		Irrep[dynkin__Integer],form:(StandardForm|TraditionalForm)]:=Module[
			{above={{BoxForm`SummaryItem[{
					 "\[GothicS]\[GothicU]("<>ToString[Length@List@dynkin + 1]<>") Irrep: ", 
					 "D("<>StringRiffle[List@dynkin,","]<>")"}]},
					{BoxForm`SummaryItem[{"Dimension Irrep: ", IrrepDimensionDynkin[List@dynkin]}]}},
			 below={{BoxForm`SummaryItem[{"Dimension Lie Algebra: ", (Length[List@dynkin]+1)^2-1}]}},
			 icon=icon
			},
			BoxForm`ArrangeSummaryBox[
				Irrep,
				List[dynkin],
				icon, above, below,
				form, "Interpretable"->True]];

	(* SummaryBox identifying a set of basis matrices for a particular irreducible representation *)
	IrrepBasis/:MakeBoxes[
		IrrepBasis[matrices_List, dynkin_List],form:(StandardForm|TraditionalForm)]:=Module[
			{above={{BoxForm`SummaryItem[{
					 "\[GothicS]\[GothicU]("<>ToString[Length@dynkin + 1]<>") representation basis: ", 
					 "D("<>StringRiffle[dynkin,","]<>")"}]},
					{BoxForm`SummaryItem[{"Dimension Irrep: ", IrrepDimensionDynkin[dynkin]}]}},
			 below={},
			 icon=icon
			},
			BoxForm`ArrangeSummaryBox[
				IrrepBasis,
				matrices,
				icon, above, below,
				form, "Interpretable"->True]];

	(* Return the Dynkin label for an irreducible representation *)
	IrrepDynkinLabel[Irrep[dynkin__Integer]]:=List@dynkin;

	(* Adding functionality to IrrepBasis:
		The elements should be indexable
		Length should give the number of basis elements *)
	IrrepBasis[matrices_List, dynkin_List][k_] := matrices[[k]];
	Unprotect[Length];
	Length[IrrepBasis[matrices_List, dynkin_List]] := Length[matrices];
	Protect[Length];

	(* Return the dimension of the vector space of the representation *)
	IrrepDimensionDynkin[irrep_List] := Module[{
		topRow=Append[Reverse@Accumulate@Reverse@irrep, 0], 
		DimIrrep=LibraryFunctionLoad[sunLibCore,"ml_dimension_irrep",{{Integer,1}},Integer]
	},
		DimIrrep[topRow]
	];

	IrrepDimension[irrep_Irrep] := IrrepDimensionDynkin[IrrepDynkinLabel[irrep]];

	(* Construct root generators *)
	IrrepBuildLoweringRootOperators[topRow_List, basis_, dim_]:=Module[{
		matrices={}, bID,
		RootLowering=LibraryFunctionLoad[sunLibCore,"ml_root_lowering",{Integer,Integer}, {Integer,_}]
	},
		matrices=Table[
			{Transpose[#[[3;;]]]->Sqrt[#[[1]]/#[[2]]]}&@RootLowering[basis,l],
			{l,Length@topRow-1}];
		SparseArray[#,{dim,dim}]&/@matrices
	];
	
	(* Helper function mapping \[DoubleStruckCapitalN]\[Rule]\[DoubleStruckCapitalN]^2 (see pairing function) *)
	LToPQ[l_]:=Module[{
		w=Floor[(Sqrt[8l+1]-1)/2], t},
		t = (w(w+1))/2;
		{l-t+1, w+1}
	];
	
	GenerateAllLowering[loweringRoot_, topRow_, TableFunction_]:=TableFunction[
		Module[{chain=Range@@pq, A},
				A=loweringRoot[[First@chain]];
				Do[A=B.A-A.B, {B, loweringRoot[[Rest@chain]]}];
				A],
		{pq, LToPQ/@(Range[(Length[topRow](Length[topRow]-1))/2]-1)}
	];

	(* Assuming Subscript[L, i] and Subscript[R, i] are the lowering and  raising operators
		generated by the root generators through repeated commutation
		and taking the adjoint and Subscript[C, i] the Cartan generators, this basis
		looks like 
		Subscript[L, 1], Subscript[R, 1], Subscript[L, 2], Subscript[R, 2] ... Subscript[L, n(n-1)/2], Subscript[R, n(n-1)/2], Subscript[C, 1], ... , Subscript[C, n-1] *)
	IrrepRLBasisMatrices[irrep_Irrep] := Module[{
		topRow=Append[Reverse@Accumulate@Reverse@IrrepDynkinLabel[irrep], 0],
		dim=IrrepDimension[irrep],
		basis,cartan,lowering,
		loweringRoot, res,
		SUNInitBasis=LibraryFunctionLoad[sunLibCore, "ml_init_basis", {{Integer,1}, Integer}, "Void"],
		SUNCartan=LibraryFunctionLoad[sunLibCore, "ml_cartan_matrix", {Integer,Integer}, {Integer,_}]
	},
		basis=CreateManagedLibraryExpression["SUNGTBasis", SUNGTBasis];
		SUNInitBasis[topRow, ManagedLibraryExpressionID@basis];
		loweringRoot=IrrepBuildLoweringRootOperators[topRow,ManagedLibraryExpressionID@basis,dim];
		cartan=Table[SparseArray[
			Transpose[{Range@dim,Range@dim}]->1/2 SUNCartan[ManagedLibraryExpressionID@basis, l],
			{dim,dim}],
			{l,Length@topRow-1}];
		lowering=GenerateAllLowering[loweringRoot, topRow, ParallelTable];
		res = Join[Flatten[Transpose@{lowering,ConjugateTranspose/@lowering}, 1], cartan];
		IrrepBasis[res, IrrepDynkinLabel[irrep]]
	];

	(* Based on the RL basis, compute (Y_{k}+Y_{k+1})/2 and (Y_{k}-Y_{k+1})/(2i) *)
	IrrepAngMomBasisMatrices[irrep_Irrep] := Module[{
		Y=IrrepRLBasisMatrices[irrep],
		dynkin=IrrepDynkinLabel[irrep],
		res, norm, csa
	},
		res = Flatten[
				Table[
					{(Y[i]+Y[i+1])/2, -(Y[i]-Y[i+1])/(2I)},
					{i, 1, Length[Y]-Length[dynkin], 2}]
				,1];
		csa = Y[Length[Y]-Length[dynkin]+1;;];
		norm = Total@Power[Diagonal@First@csa, 2];

		csa = Simplify@(
			SparseArray[Transpose@{Range@Length[#], Range@Length[#]} -> #]& /@
			Orthogonalize[Diagonal /@ csa]
		);

		csa = Sqrt[norm/Tr[#.#]]# & /@ csa;

		IrrepBasis[Table[
				If[#2 == 0, csa[[#1-1]], res[[k-#1+1]]] & @@ {#, k+1-#^2} &@ Floor@Sqrt[k+1],
				{k, Length[Y]}
			],
			dynkin]
	];

	(* Based on the RL basis, compute (Subscript[Y, k]+Subscript[Y, k+1])/2 and (Subscript[Y, k]-Subscript[Y, k+1])/(2i) *)
	DEPRECATEDIrrepAngMomBasisMatrices[irrep_Irrep] := Module[{
		Y=IrrepRLBasisMatrices[irrep],
		dynkin=IrrepDynkinLabel[irrep],
		res
	},
		res = Join[Flatten[Table[{
			(Y[i]+Y[i+1])/2, -(Y[i]-Y[i+1])/(2I)
		},
		{i, 1, Length[Y]-Length[dynkin], 2}],1], Y[Length[Y]-Length[dynkin]+1;;]];
		IrrepBasis[res, dynkin]
	];

	(* Expose the two different basis choices though an opetional argument
	   The default ist the angular momentum basis *)
	Options[LieAlgebraBasisMatrices]={BasisType->"AngularMomentum"};
	LieAlgebraBasisMatrices[irrep_Irrep, OptionsPattern[]]:=Switch[OptionValue[BasisType],
		"AngularMomentum", IrrepAngMomBasisMatrices[irrep],
		"LoweringRaising", IrrepRLBasisMatrices[irrep]
	];

	(* Explicitly construct su(3) irrep *)
	Options[SU3BasisMatrices]={BasisType->"AngularMomentum"};
	SU3BasisMatrices[p_, q_, OptionsPattern[]]:=LieAlgebraBasisMatrices[Irrep[p, q], BasisType->OptionValue[BasisType]]
	
	(* Explicitly construct su(2) irrep *)
	Options[SU2BasisMatrices]={BasisType->"AngularMomentum"};
	SU2BasisMatrices[p_, OptionsPattern[]]:=LieAlgebraBasisMatrices[Irrep[p], BasisType->OptionValue[BasisType]]
End[];
EndPackage[];
